{
  "version": 3,
  "sources": ["../../../../src/lib/miner/miner/ClaymoreMiner.ts"],
  "sourcesContent": ["import {Socket} from 'node:net';\nimport {ClaymoreMinerSettings} from '../model/MinerSettings';\nimport {PollingMiner} from './PollingMiner';\nimport {Logger} from '../model/Logger';\n\nenum ClaymoreCommandMethod {\n    minerGetStat1 = 'miner_getstat1',\n    minerGetStat2 = 'miner_getstat2',\n\n    // TRM: default (like any 'non_existent' method): \"CM API rpc method 'non_existent' is not supported.\"\n    minerFile = 'miner_file', // ATTENTION! RCE VULNERABILITY, DO NOT USE THIS METHOD (not supported by trm)\n\n    // TRM: \"CM API miner restart rpc is not supported.\"\n    minerRestart = 'miner_restart',\n\n    // TRM: \"CM API miner reboot rpc is not supported.\"\n    minerReboot = 'miner_reboot',\n\n    controlGpu = 'control_gpu',\n}\n\n// TODO: psw support\nexport class ClaymoreMiner extends PollingMiner<ClaymoreMinerSettings> {\n    private readonly logger: Logger;\n\n    constructor(settings: ClaymoreMinerSettings) {\n        super(settings);\n\n        this.logger = Logger.getLogger('ClaymoreMiner[${settings.host}:${settings.port}]');\n    }\n\n    public async connect(): Promise<void> {\n        // claymore api does not support persistent connections (socket is closed after each command)\n        return Promise.resolve();\n    }\n\n    public start(): Promise<void> {\n        return this.sendCommand(ClaymoreCommandMethod.controlGpu, ['-1', '1']);\n    }\n\n    public fetchData(): Promise<void> {\n        throw new Error('Method not implemented.');\n    }\n\n    public async stop(): Promise<void> {\n        await this.sendCommand(ClaymoreCommandMethod.controlGpu, ['-1', '0']);\n    }\n\n    public close(): Promise<void> {\n        throw new Error('Method not implemented.');\n    }\n\n    private async sendCommand(method: ClaymoreCommandMethod, params: string[]): Promise<void> {\n        this.logger.debug(`sendCommand: ${method} ${params}`);\n\n        return new Promise((resolve, reject) => {\n            const socket: Socket = new Socket();\n\n            socket.on('connect', () => {\n                const cmd = JSON.stringify({\n                    id: 0,\n                    jsonrpc: '2.0',\n                    method: method,\n                    params\n                }) + '\\n';\n                this.logger.log(`connected, sending cmd now ...: ${cmd}`);\n                socket.write(cmd);\n                socket.setTimeout(1000);\n            });\n\n            socket.on('timeout', () => {\n                socket.end();\n                socket.destroy();\n                this.logger.warn('socket timeout');\n                reject();\n            });\n\n            socket.on('data', (data) => {\n                const d = JSON.parse(data.toString());\n\n                this.logger.debug(`received: ${d}`);\n\n                resolve(d);\n            });\n\n            socket.on('close', () => {\n            }); // discard\n\n            socket.on('error', (err) => {\n                reject(`socket error: ${err.message}`);\n                this.logger.error(err.message);\n                socket.destroy();\n                resolve();\n            });\n\n            socket.connect(this.settings.port, this.settings.host);\n        });\n    }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAqB;AAErB,0BAA2B;AAC3B,oBAAqB;AAErB,IAAK,wBAAL,kBAAKA,2BAAL;AACI,EAAAA,uBAAA,mBAAgB;AAChB,EAAAA,uBAAA,mBAAgB;AAGhB,EAAAA,uBAAA,eAAY;AAGZ,EAAAA,uBAAA,kBAAe;AAGf,EAAAA,uBAAA,iBAAc;AAEd,EAAAA,uBAAA,gBAAa;AAbZ,SAAAA;AAAA,GAAA;AAiBE,MAAM,sBAAsB,iCAAoC;AAAA,EAClD;AAAA,EAEjB,YAAY,UAAiC;AACzC,UAAM,QAAQ;AAEd,SAAK,SAAS,qBAAO,UAAU,kDAAkD;AAAA,EACrF;AAAA,EAEA,MAAa,UAAyB;AAElC,WAAO,QAAQ,QAAQ;AAAA,EAC3B;AAAA,EAEO,QAAuB;AAC1B,WAAO,KAAK,YAAY,gCAAkC,CAAC,MAAM,GAAG,CAAC;AAAA,EACzE;AAAA,EAEO,YAA2B;AAC9B,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEA,MAAa,OAAsB;AAC/B,UAAM,KAAK,YAAY,gCAAkC,CAAC,MAAM,GAAG,CAAC;AAAA,EACxE;AAAA,EAEO,QAAuB;AAC1B,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEA,MAAc,YAAY,QAA+B,QAAiC;AACtF,SAAK,OAAO,MAAM,gBAAgB,MAAM,IAAI,MAAM,EAAE;AAEpD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,YAAM,SAAiB,IAAI,uBAAO;AAElC,aAAO,GAAG,WAAW,MAAM;AACvB,cAAM,MAAM,KAAK,UAAU;AAAA,UACvB,IAAI;AAAA,UACJ,SAAS;AAAA,UACT;AAAA,UACA;AAAA,QACJ,CAAC,IAAI;AACL,aAAK,OAAO,IAAI,mCAAmC,GAAG,EAAE;AACxD,eAAO,MAAM,GAAG;AAChB,eAAO,WAAW,GAAI;AAAA,MAC1B,CAAC;AAED,aAAO,GAAG,WAAW,MAAM;AACvB,eAAO,IAAI;AACX,eAAO,QAAQ;AACf,aAAK,OAAO,KAAK,gBAAgB;AACjC,eAAO;AAAA,MACX,CAAC;AAED,aAAO,GAAG,QAAQ,CAAC,SAAS;AACxB,cAAM,IAAI,KAAK,MAAM,KAAK,SAAS,CAAC;AAEpC,aAAK,OAAO,MAAM,aAAa,CAAC,EAAE;AAElC,gBAAQ,CAAC;AAAA,MACb,CAAC;AAED,aAAO,GAAG,SAAS,MAAM;AAAA,MACzB,CAAC;AAED,aAAO,GAAG,SAAS,CAAC,QAAQ;AACxB,eAAO,iBAAiB,IAAI,OAAO,EAAE;AACrC,aAAK,OAAO,MAAM,IAAI,OAAO;AAC7B,eAAO,QAAQ;AACf,gBAAQ;AAAA,MACZ,CAAC;AAED,aAAO,QAAQ,KAAK,SAAS,MAAM,KAAK,SAAS,IAAI;AAAA,IACzD,CAAC;AAAA,EACL;AACJ;",
  "names": ["ClaymoreCommandMethod"]
}
