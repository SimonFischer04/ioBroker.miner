{
  "version": 3,
  "sources": ["../../../../src/lib/miner/miner/ClaymoreMiner.ts"],
  "sourcesContent": ["import {Socket} from 'node:net';\nimport {ClaymoreMinerSettings} from '../model/MinerSettings';\nimport {PollingMiner} from './PollingMiner';\nimport {safeParseInt} from '../../utils/parse-utils';\nimport {MinerFeatureKey} from '../model/MinerFeature';\nimport {MinerStats} from '../model/MinerStats';\n\nenum ClaymoreCommandMethod {\n    minerGetStat1 = 'miner_getstat1',\n    // TRM example response: {\"id\":0, \"result\":[\"0.10.20 - kawpow\", \"2672\", \"48301;5;0\", \"48301\", \"0;0;0\", \"off\", \"69;62\", \"kawpow.auto.nicehash.com:443\", \"0;0;0;0\", \"5\", \"0\", \"0\", \"0\", \"0\", \"0\", \"3\", \"1;1;1\", \"0\"], \"error\":null}\n    minerGetStat2 = 'miner_getstat2',\n\n    minerGetFile = 'miner_getfile',\n    // TRM: default (like any 'non_existent' method): \"CM API rpc method 'non_existent' is not supported.\"\n    minerFile = 'miner_file', // ATTENTION! RCE VULNERABILITY, DO NOT USE THIS METHOD (not supported by trm)\n\n    // TRM: \"CM API miner restart rpc is not supported.\"\n    minerRestart = 'miner_restart',\n\n    // TRM: \"CM API miner reboot rpc is not supported.\"\n    minerReboot = 'miner_reboot',\n\n    controlGpu = 'control_gpu',\n}\n\nexport class ClaymoreMiner extends PollingMiner<ClaymoreMinerSettings> {\n    constructor(settings: ClaymoreMinerSettings) {\n        super(settings);\n    }\n\n    public override async init(): Promise<void> {\n        await super.init();\n        // claymore api does not support persistent connections (socket is closed after each command), so don't need to init any connection here\n        return Promise.resolve();\n    }\n\n    public override start(): Promise<void> {\n        return this.sendCommand(ClaymoreCommandMethod.controlGpu, ['-1', '1'], false);\n    }\n\n    public override async fetchStats(): Promise<MinerStats> {\n        try {\n            const response: MinerGetStat2Response = await this.sendCommand(ClaymoreCommandMethod.minerGetStat2, undefined, true);\n            const parsedResponse: ParsedMinerGetStat2Response = this.parseMinerGetStat2(response);\n            this.logger.debug(`parsed response: ${JSON.stringify(parsedResponse)}`);\n\n            return {\n                version: parsedResponse.minerVersion,\n                totalHashrate: parsedResponse.ethTotal.hashrate // actually \"ETH hashrate\" also means other hashing algorithms\n            }\n        } catch (e) { // forward error\n            return Promise.reject(e);\n        }\n    }\n\n    public override async stop(): Promise<void> {\n        await this.sendCommand(ClaymoreCommandMethod.controlGpu, ['-1', '0'], false);\n    }\n\n    public getSupportedFeatures(): MinerFeatureKey[] {\n        return [\n            MinerFeatureKey.running,\n            MinerFeatureKey.version,\n            MinerFeatureKey.totalHashrate\n        ]\n    }\n\n    public override getLoggerName(): string {\n        return `${super.getLoggerName()}ClaymoreMiner[${this.settings.host}:${this.settings.port}]`;\n    }\n\n    private async sendCommand<T = void>(method: ClaymoreCommandMethod, params?: string[], expectResponse: boolean = true): Promise<T> {\n        this.logger.debug(`sendCommand: ${method} ${params}`);\n\n        let handled = false;\n        const socket: Socket = new Socket();\n\n        return new Promise<T>((resolve, reject) => {\n            socket.on('connect', () => {\n                const cmd = JSON.stringify({\n                    id: 0,\n                    jsonrpc: '2.0',\n                    psw: this.settings.password,\n                    method: method,\n                    params\n                }) + '\\n';\n                this.logger.debug(`connected, sending cmd now ...: ${cmd}`);\n                socket.write(cmd, (err) => {\n                    if (err) {\n                        this.logger.error(err.message);\n                        reject(err.message);\n                    } else {\n                        if (!expectResponse) {\n                            resolve(undefined as T);\n                        }\n                    }\n                });\n            });\n\n            socket.on('timeout', () => {\n\n                this.logger.warn('socket timeout');\n                reject('socket timeout');\n            });\n\n            socket.on('data', (data) => {\n                const d = JSON.parse(data.toString());\n\n                this.logger.debug(`received: ${data.toString()}`);\n\n                resolve(d as T);\n            });\n\n            socket.on('close', () => {\n            }); // discard\n\n            socket.on('error', (err) => {\n                this.logger.error(err.message);\n                reject(`socket error: ${err.message}`);\n            });\n\n            socket.setTimeout(3000);\n            socket.connect(this.settings.port, this.settings.host);\n\n            // socket timeout alone does is not enough\n            setTimeout(() => {\n                if(!handled) {\n                    const msg = `timeout handling socket command: ${method} ${params}. maybe the password is wrong?`;\n                    this.logger.warn(msg);\n                    reject(msg);\n                }\n            }, 3000)\n        }).finally(() => {\n            handled = true;\n            socket.end();\n            socket.destroy();\n        });\n    }\n\n    // public to allow unit tests\n    public parseMinerGetStat1(response: MinerGetStat1Response): ParsedMinerGetStat1Response {\n        const [\n            minerVersion,\n            runningTime,\n            ethTotalStats,\n            ethDetailedHashrate,\n            dcrTotalStats,\n            dcrDetailedHashrate,\n            temperatureAndFanSpeed,\n            currentMiningPool,\n            invalidSharesAndPoolSwitches\n        ] = response.result;\n\n        const [ethHashrate, ethShares, ethRejectedShares] = (ethTotalStats || '0;0;0').split(';').map(safeParseInt);\n        const [dcrHashrate, dcrShares, dcrRejectedShares] = (dcrTotalStats || '0;0;0').split(';').map(safeParseInt);\n        const [ethInvalidShares, ethPoolSwitches, dcrInvalidShares, dcrPoolSwitches] = (invalidSharesAndPoolSwitches || '0;0;0;0').split(';').map(safeParseInt);\n\n        const gpuInfo = (temperatureAndFanSpeed || '').split(';').reduce<Array<{\n            temperature: number;\n            fanSpeed: number\n        }>>((acc, value, index, array) => {\n            if (index % 2 === 0) {\n                const temperature = safeParseInt(value);\n                const fanSpeed = safeParseInt(array[index + 1]);\n                if (temperature !== 0 || fanSpeed !== 0) {\n                    acc.push({temperature, fanSpeed});\n                }\n            }\n            return acc;\n        }, []);\n\n        return {\n            minerVersion: minerVersion || '',\n            runningTimeMinutes: safeParseInt(runningTime),\n            ethTotal: {\n                hashrate: ethHashrate,\n                shares: ethShares,\n                rejectedShares: ethRejectedShares\n            },\n            ethDetailedHashrate: ethDetailedHashrate ? ethDetailedHashrate.split(';').map(safeParseInt) : [],\n            dcrTotal: {\n                hashrate: dcrHashrate,\n                shares: dcrShares,\n                rejectedShares: dcrRejectedShares\n            },\n            dcrDetailedHashrate: dcrDetailedHashrate ? dcrDetailedHashrate.split(';').filter(s => s !== '') : [],\n            gpuInfo,\n            currentMiningPool: currentMiningPool || '',\n            stats: {\n                ethInvalidShares,\n                ethPoolSwitches,\n                dcrInvalidShares,\n                dcrPoolSwitches\n            }\n        };\n    }\n\n    // public to allow unit tests\n    public parseMinerGetStat2(response: MinerGetStat2Response): ParsedMinerGetStat2Response {\n        const parsedStat1 = this.parseMinerGetStat1(response as unknown as MinerGetStat1Response);\n        const [\n            , , , , , , , , ,\n            ethAcceptedShares,\n            ethRejectedShares,\n            ethInvalidShares,\n            dcrAcceptedShares,\n            dcrRejectedShares,\n            dcrInvalidShares,\n            pciBusIndexes\n        ] = response.result;\n\n        const parseShares = (shares: string) => shares ? shares.split(';').map(safeParseInt) : [];\n\n        return {\n            ...parsedStat1,\n            ethAcceptedShares: parseShares(ethAcceptedShares),\n            ethRejectedShares: parseShares(ethRejectedShares),\n            ethInvalidShares: parseShares(ethInvalidShares),\n            dcrAcceptedShares: parseShares(dcrAcceptedShares),\n            dcrRejectedShares: parseShares(dcrRejectedShares),\n            dcrInvalidShares: parseShares(dcrInvalidShares),\n            pciBusIndexes: parseShares(pciBusIndexes)\n        };\n    }\n}\n\nexport interface MinerGetStat1Response {\n    id: number;\n    jsonrpc: string;\n    result: [\n        string,  // Miner version\n        string,  // Running time in minutes\n        string,  // Total ETH hashrate, shares, rejected shares\n        string,  // Detailed ETH hashrate for all GPUs\n        string,  // Total DCR hashrate, shares, rejected shares\n        string,  // Detailed DCR hashrate for all GPUs\n        string,  // Temperature and Fan speed pairs for all GPUs\n        string,  // Current mining pool(s)\n        string   // ETH invalid shares, pool switches, DCR invalid shares, pool switches\n    ];\n}\n\nexport interface MinerGetStat2Response {\n    id: number;\n    jsonrpc: string;\n    result: [\n        ...MinerGetStat1Response['result'],\n        string,  // ETH accepted shares for every GPU\n        string,  // ETH rejected shares for every GPU\n        string,  // ETH invalid shares for every GPU\n        string,  // DCR accepted shares for every GPU\n        string,  // DCR rejected shares for every GPU\n        string,  // DCR invalid shares for every GPU\n        string   // PCI bus index for every GPU\n    ];\n}\n\n// Parsed interfaces\ninterface ParsedMinerGetStat1Response {\n    minerVersion: string;\n    runningTimeMinutes: number;\n    ethTotal: {\n        hashrate: number;\n        shares: number;\n        rejectedShares: number;\n    };\n    ethDetailedHashrate: number[];\n    dcrTotal: {\n        hashrate: number;\n        shares: number;\n        rejectedShares: number;\n    };\n    dcrDetailedHashrate: string[];\n    gpuInfo: Array<{\n        temperature: number;\n        fanSpeed: number;\n    }>;\n    currentMiningPool: string;\n    stats: {\n        ethInvalidShares: number;\n        ethPoolSwitches: number;\n        dcrInvalidShares: number;\n        dcrPoolSwitches: number;\n    };\n}\n\ninterface ParsedMinerGetStat2Response extends ParsedMinerGetStat1Response {\n    ethAcceptedShares: number[];\n    ethRejectedShares: number[];\n    ethInvalidShares: number[];\n    dcrAcceptedShares: number[];\n    dcrRejectedShares: number[];\n    dcrInvalidShares: number[];\n    pciBusIndexes: number[];\n}"],
  "mappings": "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",
  "names": ["ClaymoreCommandMethod"]
}
