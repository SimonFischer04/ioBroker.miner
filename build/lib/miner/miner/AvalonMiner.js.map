{
  "version": 3,
  "sources": ["../../../../src/lib/miner/miner/AvalonMiner.ts"],
  "sourcesContent": ["import { PollingMiner } from './PollingMiner';\nimport type { AvalonMinerSettings } from '../model/MinerSettings';\nimport type { MinerStats } from '../model/MinerStats';\nimport { MinerFeatureKey } from '../model/MinerFeature';\nimport { sendSocketCommand } from '../../utils/socket-utils';\nimport { Socket } from 'node:net';\n\n// Avalon miners use CGMiner-based API similar to SGMiner\n// Reference: https://github.com/c7ph3r10/ha_avalonq\n\n// Timestamp offset in seconds for Avalon control commands\n// The Avalon API requires a timestamp in the future for softon/softoff commands\nconst COMMAND_TIMESTAMP_OFFSET_SECONDS = 5;\n\n// Socket timeout for control commands in milliseconds\nconst SOCKET_TIMEOUT_MS = 3000;\n\n// Delay before closing socket after sending control command\nconst CONTROL_COMMAND_TIMEOUT_MS = 1000;\n\nenum AvalonMinerCommand {\n    stats = 'stats',\n    summary = 'summary',\n    coin = 'coin',\n    pools = 'pools',\n    devs = 'devs',\n}\n\nenum AvalonMinerControlCommand {\n    // ascset commands for Avalon Q devices\n    workmode_eco = 'ascset|0,workmode,set,0',\n    workmode_standard = 'ascset|0,workmode,set,1',\n    workmode_super = 'ascset|0,workmode,set,2',\n    softon = 'ascset|0,softon,1:', // append timestamp\n    softoff = 'ascset|0,softoff,1:', // append timestamp\n    lcd_on = 'ascset|0,lcd,0:1',\n    lcd_off = 'ascset|0,lcd,0:0',\n}\n\n/**\n * Avalon Miner implementation\n * Supports Canaan Avalon miners (e.g., Avalon Q Home Miner)\n */\nexport class AvalonMiner extends PollingMiner<AvalonMinerSettings> {\n    /**\n     * Start/resume the miner from standby\n     */\n    public override async start(): Promise<void> {\n        const timestamp = Math.floor(Date.now() / 1000) + COMMAND_TIMESTAMP_OFFSET_SECONDS;\n        await this.sendControlCommand(`${AvalonMinerControlCommand.softon}${timestamp}`, false);\n    }\n\n    /**\n     * Fetch stats from the miner\n     */\n    public override async fetchStats(): Promise<MinerStats> {\n        try {\n            // Fetch multiple stats in parallel for comprehensive monitoring\n            const [summary, stats, coin, pools, devs] = await Promise.all([\n                this.sendCommand<object>(AvalonMinerCommand.summary, '', true).catch(() => null),\n                this.sendCommand<object>(AvalonMinerCommand.stats, '', true).catch(() => null),\n                this.sendCommand<object>(AvalonMinerCommand.coin, '', true).catch(() => null),\n                this.sendCommand<object>(AvalonMinerCommand.pools, '', true).catch(() => null),\n                this.sendCommand<object>(AvalonMinerCommand.devs, '', true).catch(() => null),\n            ]);\n\n            return {\n                raw: {\n                    summary,\n                    stats,\n                    coin,\n                    pools,\n                    devs,\n                },\n            };\n        } catch (e) {\n            return Promise.reject(e instanceof Error ? e : new Error(String(e)));\n        }\n    }\n\n    /**\n     * Stop/pause the miner (send to standby)\n     */\n    public override async stop(): Promise<void> {\n        const timestamp = Math.floor(Date.now() / 1000) + COMMAND_TIMESTAMP_OFFSET_SECONDS;\n        await this.sendControlCommand(`${AvalonMinerControlCommand.softoff}${timestamp}`, false);\n    }\n\n    /**\n     * Get supported features for Avalon miners\n     */\n    public override getSupportedFeatures(): MinerFeatureKey[] {\n        return [MinerFeatureKey.running, MinerFeatureKey.rawStats];\n    }\n\n    /**\n     * Get logger name for this miner\n     */\n    public override getLoggerName(): string {\n        return `${super.getLoggerName()}AvalonMiner[${this.settings.host}:${this.settings.port}]`;\n    }\n\n    /**\n     * Get CLI arguments (not applicable for Avalon as it's a standalone device)\n     */\n    public override getCliArgs(): string[] {\n        return [];\n    }\n\n    /**\n     * Send a CGMiner-style command\n     *\n     * @param command - The command to send\n     * @param parameter - Optional parameter for the command\n     * @param expectResponse - Whether to expect a response\n     */\n    private async sendCommand<T = void>(\n        command: AvalonMinerCommand,\n        parameter: string = '',\n        expectResponse: boolean = true,\n    ): Promise<T> {\n        return sendSocketCommand(\n            this.logger,\n            this.settings.host,\n            this.settings.port,\n            {\n                command,\n                parameter,\n            },\n            expectResponse,\n        );\n    }\n\n    /**\n     * Send an Avalon-specific control command (ascset)\n     *\n     * @param command - The control command to send\n     * @param expectResponse - Whether to expect a response\n     */\n    private async sendControlCommand(command: string, expectResponse: boolean = false): Promise<void> {\n        // Avalon control commands are sent as raw strings, not JSON\n        // We'll use a simplified socket approach here\n        const socket = new Socket();\n        let timeoutHandle: NodeJS.Timeout | undefined;\n\n        return new Promise<void>((resolve, reject) => {\n            socket.on('connect', () => {\n                this.logger.debug(`sending control command: ${command}`);\n                socket.write(`${command}\\n`, err => {\n                    if (err) {\n                        this.logger.error(err.message);\n                        reject(new Error(err.message));\n                    } else {\n                        if (!expectResponse) {\n                            resolve();\n                        }\n                    }\n                });\n            });\n\n            socket.on('timeout', () => {\n                this.logger.warn('socket timeout');\n                reject(new Error('socket timeout'));\n            });\n\n            socket.on('error', err => {\n                this.logger.error(err.message);\n                reject(new Error(`socket error: ${err.message}`));\n            });\n\n            socket.setTimeout(SOCKET_TIMEOUT_MS);\n            socket.connect(this.settings.port, this.settings.host);\n\n            timeoutHandle = setTimeout(() => {\n                socket.end();\n                socket.destroy();\n            }, CONTROL_COMMAND_TIMEOUT_MS);\n        }).finally(() => {\n            if (timeoutHandle) {\n                clearTimeout(timeoutHandle);\n            }\n            socket.end();\n            socket.destroy();\n        });\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAA6B;AAG7B,0BAAgC;AAChC,0BAAkC;AAClC,sBAAuB;AAOvB,MAAM,mCAAmC;AAGzC,MAAM,oBAAoB;AAG1B,MAAM,6BAA6B;AAEnC,IAAK,qBAAL,kBAAKA,wBAAL;AACI,EAAAA,oBAAA,WAAQ;AACR,EAAAA,oBAAA,aAAU;AACV,EAAAA,oBAAA,UAAO;AACP,EAAAA,oBAAA,WAAQ;AACR,EAAAA,oBAAA,UAAO;AALN,SAAAA;AAAA,GAAA;AAQL,IAAK,4BAAL,kBAAKC,+BAAL;AAEI,EAAAA,2BAAA,kBAAe;AACf,EAAAA,2BAAA,uBAAoB;AACpB,EAAAA,2BAAA,oBAAiB;AACjB,EAAAA,2BAAA,YAAS;AACT,EAAAA,2BAAA,aAAU;AACV,EAAAA,2BAAA,YAAS;AACT,EAAAA,2BAAA,aAAU;AART,SAAAA;AAAA,GAAA;AAeE,MAAM,oBAAoB,iCAAkC;AAAA;AAAA;AAAA;AAAA,EAI/D,MAAsB,QAAuB;AACzC,UAAM,YAAY,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI,IAAI;AAClD,UAAM,KAAK,mBAAmB,GAAG,iCAAgC,GAAG,SAAS,IAAI,KAAK;AAAA,EAC1F;AAAA;AAAA;AAAA;AAAA,EAKA,MAAsB,aAAkC;AACpD,QAAI;AAEA,YAAM,CAAC,SAAS,OAAO,MAAM,OAAO,IAAI,IAAI,MAAM,QAAQ,IAAI;AAAA,QAC1D,KAAK,YAAoB,yBAA4B,IAAI,IAAI,EAAE,MAAM,MAAM,IAAI;AAAA,QAC/E,KAAK,YAAoB,qBAA0B,IAAI,IAAI,EAAE,MAAM,MAAM,IAAI;AAAA,QAC7E,KAAK,YAAoB,mBAAyB,IAAI,IAAI,EAAE,MAAM,MAAM,IAAI;AAAA,QAC5E,KAAK,YAAoB,qBAA0B,IAAI,IAAI,EAAE,MAAM,MAAM,IAAI;AAAA,QAC7E,KAAK,YAAoB,mBAAyB,IAAI,IAAI,EAAE,MAAM,MAAM,IAAI;AAAA,MAChF,CAAC;AAED,aAAO;AAAA,QACH,KAAK;AAAA,UACD;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,SAAS,GAAG;AACR,aAAO,QAAQ,OAAO,aAAa,QAAQ,IAAI,IAAI,MAAM,OAAO,CAAC,CAAC,CAAC;AAAA,IACvE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAsB,OAAsB;AACxC,UAAM,YAAY,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI,IAAI;AAClD,UAAM,KAAK,mBAAmB,GAAG,mCAAiC,GAAG,SAAS,IAAI,KAAK;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA,EAKgB,uBAA0C;AACtD,WAAO,CAAC,oCAAgB,SAAS,oCAAgB,QAAQ;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKgB,gBAAwB;AACpC,WAAO,GAAG,MAAM,cAAc,CAAC,eAAe,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,IAAI;AAAA,EAC1F;AAAA;AAAA;AAAA;AAAA,EAKgB,aAAuB;AACnC,WAAO,CAAC;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,YACV,SACA,YAAoB,IACpB,iBAA0B,MAChB;AACV,eAAO;AAAA,MACH,KAAK;AAAA,MACL,KAAK,SAAS;AAAA,MACd,KAAK,SAAS;AAAA,MACd;AAAA,QACI;AAAA,QACA;AAAA,MACJ;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAc,mBAAmB,SAAiB,iBAA0B,OAAsB;AAG9F,UAAM,SAAS,IAAI,uBAAO;AAC1B,QAAI;AAEJ,WAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC1C,aAAO,GAAG,WAAW,MAAM;AACvB,aAAK,OAAO,MAAM,4BAA4B,OAAO,EAAE;AACvD,eAAO,MAAM,GAAG,OAAO;AAAA,GAAM,SAAO;AAChC,cAAI,KAAK;AACL,iBAAK,OAAO,MAAM,IAAI,OAAO;AAC7B,mBAAO,IAAI,MAAM,IAAI,OAAO,CAAC;AAAA,UACjC,OAAO;AACH,gBAAI,CAAC,gBAAgB;AACjB,sBAAQ;AAAA,YACZ;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL,CAAC;AAED,aAAO,GAAG,WAAW,MAAM;AACvB,aAAK,OAAO,KAAK,gBAAgB;AACjC,eAAO,IAAI,MAAM,gBAAgB,CAAC;AAAA,MACtC,CAAC;AAED,aAAO,GAAG,SAAS,SAAO;AACtB,aAAK,OAAO,MAAM,IAAI,OAAO;AAC7B,eAAO,IAAI,MAAM,iBAAiB,IAAI,OAAO,EAAE,CAAC;AAAA,MACpD,CAAC;AAED,aAAO,WAAW,iBAAiB;AACnC,aAAO,QAAQ,KAAK,SAAS,MAAM,KAAK,SAAS,IAAI;AAErD,sBAAgB,WAAW,MAAM;AAC7B,eAAO,IAAI;AACX,eAAO,QAAQ;AAAA,MACnB,GAAG,0BAA0B;AAAA,IACjC,CAAC,EAAE,QAAQ,MAAM;AACb,UAAI,eAAe;AACf,qBAAa,aAAa;AAAA,MAC9B;AACA,aAAO,IAAI;AACX,aAAO,QAAQ;AAAA,IACnB,CAAC;AAAA,EACL;AACJ;",
  "names": ["AvalonMinerCommand", "AvalonMinerControlCommand"]
}
